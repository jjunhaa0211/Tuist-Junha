# **Features Architecture**

<aside>
💡 Apple OS 애플리케이션을 구성하여 확장성을 활성화하고 빌드 및 테스트 주기를 최적화하는 아키텍처 접근 방식

</aside>

### 목표

핵심 목표는 간결한 API를 사용하여 상호 연결된 독립적인 기능을 구축하여 앱을 구축하는 것 입니다.

### 유래

(마이크로피처)는 서로 다른 백엔드 기능이 서로 통신할 수 있도록 정의된 API를 사용하여 서로 다른 서비스로 실행되는 마이크로 서비스 아키텍처에서 유래됨

## 배경

앱은 기능들로 구성되있음. 이러한 기능들은 동일한 모듈이나 타겟의 일부로 포함되어 있습니다. 이러한 기능은 동일한 모듈이나 타겟의 일부로 포함되며, 전체 애플리케이션으로 포함됨

이렇게 하면 애플리케이션과 그 테스트 타겟은 복잡도가 증가하며 버그, 성능이 좋지 못함 컴파일 시간의 문제의 원인이 됩니다. 

## 동기

큰 Xcode 코드베이스의 확장성을 지원하면서 플랫폼 기능과 도구를 활용하는 것입니다.

React Native는 javaScript의 동적 특성을 활용하여 개발자들에게 코드베이스에서 작업하는 좋은 경험을 제공했기 때문에 동시에 사용자 관점에도 네이티브 경험을 제공합니다.

tuist 친구들은 네이티브 도구와 기술의 사용을 최적화하여 프로젝트에서 늦거나 이른 시기에 나타나는 확장성에 관련된 도전들을 극복할 수 있다고 생각하고 있음

## 핵심 원칙

- 개발자들은 앱 과는 독립적으로 빠르게 자신의 기능을 구축 및 테스트할 수 있어야함

## MFA란?

<aside>
💡 애플리케이션의 기능을 나타내며 5가지 타겟 조합이 있습니다.

</aside>

> 아래는 사전에 알고 가면 좋은 것을 적었습니다.
> 

### 인터페이스?

- 기능의 공개 인터페이스와 모델을 포함한 타겟입니다.

### 테스트?

- 기능의 단위 및 통합 테스트가 있습니다.

### 테스팅?

- 테스트 및 예제 앱에서 사용할 수 있는 테스트 데이터를 제공하고 MFA 클래스와 프로토콜에 대한 모의 객체를 제공함

### 기능(Feature)?

- 구현을 제공하는 모델과 인터페이스를 포함하므로 FeatureInterface에 종속됨

### 기능 테스팅(FeatureTesting)?

- FeatureInterface에 종속되어 기능 내에 포함된 모델과 인터페이스에 대한 테스트 데이터와 모의 객체가 있음

### 기능 예제(FeatureExample)?

- 테스트 데이터에 액세스 하기 위해 FeatureTesting에 종속됨
- Feature를 인스턴스화하고 예제 앱에서 이를 보여주기 위해 사용함
    - 이해 쉽게
        - 기능테스팅은 기능에 대한 테스트 데이터와 모의 객체를 제공함
        - 기능 예제는 이 테스트 데이터에 접근하기 위해 기능 테스팅에 종속되어 있습니다.
        - 예제 앱에서 특정 상황이나 데이터를 시뮬레이션하고 테스트하기 위해 필요한 데이터를 활용함
        - Feature를 인스턴스화하고 예제 앱에서 이를 보여주는데 사용
            - 기능 예제는 실제로 기능을 만들어 내는 데 사용되는 클래스나 모듈을 인스턴스화 합니다.
            - 여기서 이제 시뮬레이션하고 이를 데모라고 함
        - 요약
            - 기능 예제는 기능 테스팅에서 얻은 데이터를 활용하여 실제 기능을 만들고 이를 예제 앱에서 시연함

## 5가지 타겟

### app

- 실제 프로덕트 레벨을 관리합니다. APP은 재사용 보다는 모든 것을 합치는 Composition 역활을 함

### Feature

- Flow를 담당함
- 하나의 Feature는 하나의 데모앱으로 동작할 수 있음
- UI와 유저의 액션을 처리하고 UI에 반영시키는 비지니스로직을 담당합니다.

### Domain

- 하나의 관심사 별 역활을 담당함
- api 로직과 내부 Core 로직을 묶어서 Featrue에서 사용할 수 있도록 합니다.
- 외부 API에서 DTO와 Feature에서 필요한 Model 등을 담당합니다.
- CoreNetwork와 CoreKeyChain을 디펜던시로 갖습니다.

### Core

- Core는 일반적인 역활을 함
- 재사용성을 높이기 위해서 사용하는 툴

### Shared

- Shared는 모든 layer에서 공용으로 사용될 모듈을 담당합니다.
- 디자인시스템, 유틸, 로깅, 익스텐션 등 처럼 모든 곳에서 사용될 모듈을 제공함으로써 재사용성을 높인다.

![스크린샷 2023-08-25 오후 4.15.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/15cd27fe-5221-4620-a8ad-78df4edf70a7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.15.29.png)

Example

- 데모앱이라고 부름
- 기능을 테스트 할 수 있는 작은 앱 타겟

Tests

- 테스트
- unit test

Testing

- 테스트를 위한 목업
- interface 모듈의 Mocking을 제공

Implment

- 구현하는 곳
- 실제 기능을 구현하는 모듈

Interface

- UI
- feature 기능 중 외부에 공개할 interface

## 왜 MFA를 사용하는가?

> 명확하고 간결한 API
> 

```jsx
앱 소스 코드가 모두 동일한 타겟에 존재하면 코드 내에 종속성을 쉽게 만들어내며 스빠꼐띠 코드가
될 수 있습니다. 모든 것은 강력하게 결합되어 있으며 상태가 떄로는 예측할 수 없게 됩니다.
기능을 독립적 타겟으로 정의할 떄는 기능 구현 API를 결정해야함 
```

1. 무엇을 공개하는지
2. 기능을 어떻게 사용하여 하는지
3. 무엇을 비공개로 유지해야하는지
4. 기능을 어떻게 사용해야 하는지
5. 무엇을 비공개로 유지해야하는지

> 작은 모듈
> 

```jsx
작은 모듈에서 작업하는 것은 더 많은 집중력을 가질 수 있게 하며, 기능을 고립되 상태에서
테스트하고 시도할 수 있습니다. 게다가 개발 주기는 더 선택적인 컴파일을 가지므로 기능이
작동하는 데 필요한 구성요소만 컴파일 하기에 더 빨라집니다.
```

> 재사용성
> 

```jsx
다른 앱과의 확장성이 높아집니다.
```

> 내부 배포
> 

```jsx
데모앱을 추가하면서 디자이너, QA와 협업이 높아진다
```

## Feature의 종류

**Foundation**

다른 Feature를 구축하는데 사용되는 기반 도구를 포함합니다.

ex) UI 구성 요소, 테스팅 도구, 앱의 기반 기능을 제공하는 Core에 속함

**Product**

사용자가 실제로 체험하고 상호작용할 수 있는 기능을 포함합니다.
ex) 검색 기능, 결제 처리 로직, 홈화면과 같은 주요기능이 속함

<aside>
👍🏿 위를 2개로 나눈이유는 유형별로 나누어 사용함으로써 코드의 모듈화하고 재사용 가능한 구조를 구축할 수 있습니다.

</aside>

## Feature 간의 의존성

하나의 Feature가 다른 Feature에 의존할 떄 2가지 장점이 생김

1. 각 Feature의 실제 내부 작덥이 다른 Featrue의 내부와 엉켜서 얽히지 않았습니다.
2. 처음부터 앱을 만들 떄 필요한 부분만 선택해서 빌드하기에 빌드 속도가 빨라짐

<aside>
👍🏿  의존성을 잘해야함

</aside>

## 참고

https://swiftrocks.com/reducing-ios-build-times-by-using-interface-targets

https://docs.tuist.io/building-at-scale/microfeatures/#product

https://alexanderweiss.dev/blog/2022-01-12-scale-up-your-app-with-microfeatures

참고 개발 코드

https://github.com/tuist/microfeatures-example
